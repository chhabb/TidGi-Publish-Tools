created: 20250515112649996
modified: 20250515193241636
tags: 计算机科学/操作系统与虚拟化/Linux/知识体系
title: 计算机科学/操作系统与虚拟化/Linux/知识体系/监测磁盘空间

!! ''mount''

mount 是 Linux 系统中用于挂载文件系统的命令，其作用是将存储设备（如硬盘分区、U 盘、ISO 镜像等）与系统的目录结构连接起来，从而访问设备中的数据。

* mount 设备文件 挂载点：将设备文件挂载到挂载点上，挂载点必须是一个已经存在的空目录。

默认情况下，mount 命令输出当前系统已挂载的设备列表，可以查看当前挂载情况。

mount 命令提供了4部分信息。

* 设备文件名
* 设备在虚拟目录中的挂载点
* 文件系统类型
* 已挂载设备的访问状态

比如：

* /dev/sda1 on / type ext4 (rw,relatime)，表示：
** 设备 /dev/sda1
** 挂载在 / 根目录上
** 使用的是 ext4 文件系统
** 当前是以读写（rw）方式挂载，并启用了 relatime（访问时间优化）

!!! ''选项''

!!!! ''-t''

-t 指定挂载的文件系统类型（比如 ext4、vfat、ntfs、iso9660 等），告诉系统该设备用哪种文件系统驱动来解析。Linux 支持很多种文件系统，不同的设备或镜像文件可能采用不同格式，明确指定类型有助于避免识别错误。

* mount -t 文件系统类型 设备文件 挂载点

常见的文件系统类型有：

* ext4：现代 Linux 系统默认的文件系统
* vfat：FAT32 格式，广泛用于 U 盘、相机卡等
* ntfs：Windows 常用文件系统，Linux 可读写（需要 ntfs-3g）
* iso9660：CD/DVD 光盘镜像格式
* tmpfs：内存临时文件系统，用于临时存储数据
* nfs：网络文件系统
* xfs、btrfs：其他高级文件系统

示例：

* mount -t vfat /dev/sdb1 /mnt/usb：挂载一个 FAT32 的 U 盘，设备名字是 /dev/sdb1，挂载在 /mnt/usb
* mount -t ntfs /dev/sdc1 /mnt/usb：挂载一个 NTFS 的移动硬盘，设备名字是 /dev/sdc1，挂载在 /mnt/usb

不使用 -t 时，Linux 会尝试自动识别文件系统类型，大多数情况下是可以成功的，但在识别失败、或你需要精确控制时，就应该显式使用 -t。

`mount -t 文件系统类型` 这个命令如果没有后续参数（设备和挂载点），它的作用并不是挂载，而是列出当前系统中该类型的挂载信息（区别于 mount 命令非常杂乱的默认输出，让人摸不着头脑。如果知道设备分区使用的文件系统类型，可以像这样过滤输出）。

* mount -t 文件系统类型

它的行为类似于：

* mount | grep 文件系统类型

例子：

* mount -t ext4：显示当前系统中所有 ext4 文件系统 的挂载情况，也就是等价于在所有挂载信息中筛选出 ext4 类型的。

!!!! ''-o''

-o 用于指定挂载时的附加参数（挂载选项）。-o 是 --options 的简写，后面跟一串以逗号分隔的选项，用于控制设备的挂载方式或行为。

* mount -o 选项1,选项2,... 设备 挂载点

常见选项说明

* rw：以读写方式挂载（默认）
* ro：以只读方式挂载
* loop：将普通文件作为块设备挂载（通常用于 ISO 镜像）
* noexec：不允许执行挂载设备上的二进制文件
* exec：允许执行（默认）
* nosuid：忽略挂载设备上文件的 setuid 和 setgid 权限
* nodev：不解释设备文件
* uid=1000：设置挂载文件的所有者（通常用于 vfat、ntfs）
* gid=1000：设置挂载文件的用户组
* utf8：用于 FAT 文件系统，支持 UTF-8 编码
* defaults：使用默认挂载选项（rw, suid, dev, exec, auto, nouser, async）
* relatime：仅记录比上次修改时间更新的访问时间（比 atime 更高效）

示例

* mount -o ro /dev/sdb1 /mnt/usb：以只读方式挂载
* mount -o loop ubuntu.iso /mnt/iso：挂载一个 ISO 镜像
* mount -t vfat -o uid=1000,gid=1000 /dev/sdb1 /mnt/usb：挂载 FAT32 并设置文件所有者为当前用户（假设 UID 为 1000）
* mount -o loop,ro ubuntu.iso /mnt/iso：同时指定多个选项

-t 和 -o 组合使用的例子：mount -t iso9660 -o loop ubuntu.iso /mnt/iso

* 意思是把一个名为 ubuntu.iso 的 ISO 镜像文件当作一张光盘挂载到目录 /mnt/iso，你可以像浏览普通文件夹一样访问里面的内容。
** mount：使用挂载命令
** -t iso9660：指定文件系统类型为 iso9660，这是光盘镜像（如 .iso 文件）常用的文件系统格式
** -o loop：告诉系统将 ubuntu.iso 文件当作一个块设备挂载，而不是物理磁盘（这是关键）
** ubuntu.iso：镜像文件路径
** /mnt/iso：挂载点目录，挂载成功后这个目录中会出现镜像的全部内容

这是挂载 ISO 镜像的标准写法，适用于查看或提取镜像文件内容，不需要刻录或解压，直接通过文件系统访问。执行前需确保 /mnt/iso 目录存在。

!! ''umount''

umount 用于卸载文件系统，它的作用是将之前通过 mount 命令挂载的设备或目录从当前系统中解除挂载，使得该设备或路径不再被访问。

Linux 不允许直接弹出已挂载的CD或DVD（也应该避免直接将设备拔下）。如果在从光驱中移除 CD 或 DVD 时遇到麻烦，那么最大的可能是它还在虚拟目录中挂载着。应该''先卸载，然后再尝试弹出，然后再拔下设备。''

* umount <挂载点路径> 或 <设备名>

例子：

* umount /mnt/usb：这是一个挂载点
* umount /dev/sdb1：这是一个设备

注意：

* 要卸载的挂载点不能有进程正在使用（包括终端、文件浏览器、后台程序等），否则会提示“device is busy”。可以通过 lsof 或 fuser 查找占用：
** lsof /mnt/usb
** fuser -vm /mnt/usb
* 卸载前最好切换到别的目录，确保当前工作目录不是目标挂载点或其子目录。
* 可加 -l 参数（lazy），表示“延迟卸载”，适合正在被使用但又必须卸载的情况。系统会在设备不再被占用时自动完成卸载：umount -l /mnt/usb
* 有时需要使用 root 权限执行。

!!! ''选项''

!!!! ''-a''

-a 用来批量卸载所有在 /etc/mtab 中列出的挂载项，但它并不会无脑卸载一切，而是有选择地卸载特定类型的挂载点。

* umount -a

umount 默认是卸载一个挂载点（或设备），但加上 -a（即 --all）参数后，它会尝试卸载当前系统中所有通过 /etc/mtab（或者 /proc/mounts）登记的挂载项中符合卸载条件的条目。

其中一个常见场景是配合 /etc/fstab 中的 noauto 和 auto 参数使用。比如某些挂载点标记为 auto，表示可以在启动时自动挂载，也可通过 umount -a 自动卸载。

默认行为中，umount -a 会跳过以下内容：

* 根文件系统（/）不会被卸载
* 内核伪文件系统（如 /proc, /sys, /dev）通常不会被卸载，除非你手动写入 /etc/mtab
* 忽略处于忙状态（有程序占用）的挂载点

!!!! ''-t''

 -t 的作用是指定文件系统类型来卸载挂载点，通常和 -a 一起使用，比如：

* umount -a -t 文件系统类型：卸载指定类型的所有挂载点。

单独使用没有任何意义，比如：

* umount -t 文件系统类型：不指定挂载点或设备名，实际上没有什么实际意义，也不会执行卸载操作。

但是也可以用来卸载单个挂载点、设备：

* umount -t 文件系统类型 挂载点路径/设备名：卸载指定类型的挂载点/设备（卸载单个挂载点、设备）。

例子：

* umount -a -t vfat,ntfs：
** -a：卸载所有符合条件的挂载项（扫描 /etc/mtab 或 /proc/mounts）
** -t vfat,ntfs：仅限文件系统类型为 vfat 或 ntfs 的挂载点
** 意思是卸载所有 FAT 和 NTFS 类型的设备（例如插入的 U 盘或移动硬盘）

* umount -t ext4 /dev/sda1
* 卸载 ext4 类型的 /dev/sda1，但其实不加 -t 也能卸载，除非你想明确指定。

!! ''df''

df 用来查看文件系统的磁盘空间占用情况。

* df：默认将以千字节（KB）为单位显示所有已挂载文件系统的空间使用情况。
* df 文件名|路径：如果提供了文件名或路径，df 会查找你提供的文件名、“路径”所在的文件系统，并显示该文件系统的磁盘使用情况，而不是文件的大小。

!!! ''选项''

!!!！''-t''

-t 用于过滤显示指定类型的文件系统。

* df -t 文件系统类型：只列出某一类文件系统类型的磁盘使用情况

该命令的输出如下。

* 设备文件位置
* 包含多少以1024字节为单位的块
* 使用了多少以1024字节为单位的块
* 还有多少以1024字节为单位的块可用
* 已用空间所占的百分比
* 设备挂载点

!!!！''-h''

-h 是以人类可读的格式显示磁盘空间使用情况。意思是将磁盘容量自动换算为 KB / MB / GB 等单位，方便人眼查看。

* df -h：默认查看系统中所有已挂载的文件系统的磁盘使用情况；
* df -h 文件名|文件路径|目录：根据你提供的路径定位到它所属的挂载点，显示该挂载点的文件系统的磁盘使用情况。

示例输出：

```
文件系统        容量  已用  可用 已用% 挂载点
/dev/sda2        50G   20G   28G   42% /
tmpfs           1.9G     0  1.9G    0% /dev/shm
/dev/sdb1       100G   90G   10G   90% /mnt/data
```

* 文件系统：对应的设备或分区名称
* 容量：该文件系统的总大小
* 已用：已占用的空间
* 可用：还剩下的空间
* 已用%：使用比例
* 挂载点：这个文件系统被挂载到系统的哪个目录下

注意： df 不是用来查看文件或目录本身大小的工具，而是查看挂载的文件系统的空间使用状况

补充：

1、[[文件系统、文件系统类型和挂载点|计算机科学/操作系统与虚拟化/Linux/实际问题/文件系统、文件系统类型和挂载点]]

2、如何了解一个 Linux 的磁盘占用情况：

文件系统          1K的块    已用     可用 已用% 挂载点
udev             1958444       0  1958444    0% /dev
tmpfs             397380    1412   395968    1% /run
/dev/sda1      101639152 6761148 89668816    8% /
tmpfs            1986884       0  1986884    0% /dev/shm
tmpfs               5120       8     5112    1% /run/lock
tmpfs             397376     108   397268    1% /run/user/1000

Linux系统的磁盘占用情况不像Windows那样简单地显示为一个整体盘符，原因在于Linux采用了多文件系统挂载的方式。你的Debian系统中看到的很多文件系统（比如 udev、tmpfs）其实是虚拟文件系统，用于系统设备管理和内存缓存等，不是真实的硬盘分区。这些虚拟文件系统大小动态变化，通常占用很少实际存储空间。

要全面了解整个Linux系统的真实磁盘占用，重点是关注硬盘的物理分区对应的文件系统，比如你的例子中 /dev/sda1 就是真实的硬盘分区。它挂载在根目录 / 上，显示了该分区的总大小、已用和可用空间。

因为，Linux系统中磁盘空间的使用情况分散在多个“文件系统”上，其中大部分是虚拟的或者临时的（比如tmpfs、udev），它们并不占用实际的硬盘空间。真正反映你硬盘上数据占用情况的是那些“真实”的硬盘分区设备对应的文件系统，比如 /dev/sda1，它代表硬盘上的一个分区，被格式化成某种文件系统后挂载到某个目录（比如根目录 /）。这些物理分区才是你硬盘空间的实际存储区域，查看它们的使用情况，才能准确知道硬盘的空间占用和剩余情况。因此，全面了解系统磁盘使用，关键在于关注这些物理分区对应的文件系统，而不是那些临时或虚拟挂载的文件系统。

你可以用以下方式更清楚地查看：

* 运行 lsblk，查看所有块设备及其挂载点，帮助理解哪些是真实存储设备，哪些是虚拟文件系统。
* 使用 df -hT，显示所有挂载文件系统及其类型和大小，更直观区分物理和虚拟文件系统。
* 查看分区表（如 sudo fdisk -l），了解硬盘的具体分区布局。

总之，关注物理磁盘分区（如 /dev/sda1, /dev/sdb1）对应的挂载点，才能准确了解实际的磁盘使用情况。虚拟文件系统一般体积小，且是系统运行必需的，不代表磁盘真正占用。

!! ''du''

du（disk usage）命令用于查看文件或目录实际占用了多少磁盘空间，重点是内容的实际大小，而不是所在分区的剩余空间。与 df 不同，df 显示的是整个文件系统的空间占用情况，而 du 关注的是指定文件或目录本身的大小。

du 是通过遍历目录中的文件，读取文件的 inode 中记录的块大小，然后加总出来的实际使用空间。它更贴近你实际“放了多少东西”。

* du 
* du 路径
* du 路径1 路径2
* du 文件名
* du 文件名1 文件名2
* du 路径1 文件名1 路径2 文件名2

默认行为：

** 在默认情况下，不带参数，会递归地遍历当前目录及其所有子目录，等价于 du .。注意，du 统计当前目录的大小、递归遍历统计所有子目录的大小，但是输出结果不包含文件，只包含当前目录及其所有子目录。du 的输出每一行表示该文件或目录 `自身 + 子项的总磁盘占用`，所以只看最后一行 . 就知道整个当前目录下所有文件和子目录的占用。
** 指定目录，统计目录及其所有内容的占用，同样的默认也只输出目录。
** 指定多个目录，一次性统计多个路径，每个都独立输出占用。
** 当 du 的参数是一个文件时，它会输出这个文件实际占用的磁盘空间，而不是文件内容的字节数。因为文件在磁盘上是按块（block）存储的，实际占用大小通常比文件字节数大，尤其是小文件。
** 输出每个目录（不包括单独文件）的磁盘占用大小
** 单位为 1KB 块（除非系统设置为其他）
** 输出格式为：[占用空间] [目录路径]

在一个目录下运行 du，可能会输出如下内容：

```
4       ./docs/subdir
12      ./docs
8       ./logs
24      .
```

解释：

* ./docs/subdir 占用 4KB
* ./docs（包括其下所有内容）共占用 12KB
* ./logs 占用 8KB
* 当前目录 . 总占用 24KB

注意几点：

* 它不显示文件的大小，只显示目录（但是文件和目录全都参与统计）
* 输出包含所有子目录的合计数据
* 每一行的第一列是以 1K 块为单位的空间占用，不是字节数

示例：

* du，等价于 du .，默认统计当前目录下所有子目录的磁盘占用情况（会统计，但是不会显示文件，文件大小会显示在其父文件夹中）。
* du /var/log，统计 /var/log 目录及其所有内容的占用。
* du file1.txt /etc /home/user，一次性统计多个路径，每个都独立输出占用。
* du -sh /home/user，总结式输出该用户目录大小
* du -h，显示当前目录下所有子文件和子目录的大小，单位自动转换（比如 KB、MB、GB），适合人眼查看。
* du -h /etc，查看 /etc 各子目录占用
* du -sh 路径，只显示指定路径（目录或文件）的总大小（加 s 表示 summary），最常用于查看某个目录占用了多少空间。
* du -sh *，当前目录下各个文件夹（或文件）各自大小
* du -ch /usr/bin，每一项大小 + 总大小合计

常见组合与使用情形：

* du -h --max-depth=1：查看当前目录下每个子目录的大小（常用于排查空间问题），会输出当前目录中每个子目录的空间占用情况（只看一层），其中最后一行是整个目录的总大小。
* du -sh /var：只查看目录总大小（适合统计整体空间）
* du -h myfile.txt：查看单个文件大小（单位为磁盘空间而非字节数）
* du -sh /home /var /usr：查看多个路径的空间大小，每个路径单独作为一行输出
* du -ch *：统计占用总量（带 total），会显示所有文件和目录大小并加一个 total。


!!! ''选项''

!!!! ''-a''

显示每个文件的大小（默认只显示目录大小）

!!!! ''-c''

-c 的作用是在 du 输出的最后加上一行总计（total），表示所有列出的目录或文件占用空间的总和。单位默认为 KB（块大小），可配合 -h 使用人类可读格式（如 du -ch）。

* du -c 路径1 路径2 路径3：不带路径，默认为当前目录 .

想知道当前目录（或多个指定目录）下各项占用空间以及总和时使用。

!!!! ''-h''

将字节自动转换为 KB、MB、GB 等易读格式。默认单位是 1KB 的 block。

!!!! ''-s''

只显示指定路径的总和，而不显示其子目录的大小列表（是递归处理了的，只是不显示）。

!!!! ''-x''

限制只统计当前文件系统中的文件，不跨文件系统（挂载点）

!!!! ''--max-depth=N''

显示到指定的目录深度。例如 --max-depth=1 显示顶层目录及其子目录的大小总和，不深入到更深层