created: 20250515075030819
modified: 20250515104325406
tags: 计算机科学/操作系统与虚拟化/Linux/知识体系
title: 计算机科学/操作系统与虚拟化/Linux/知识体系/探查进程

!! ''ps''

ps 是 Linux 中用于查看当前系统进程（process status）的命令，常用于诊断系统状态、查找卡顿、查看某程序是否在运行等情况。

因为历史原因，ps 命令融合了三种选项风格（Unix、BSD、GNU），导致该命令的选项非常多。且三种选项风格不仅是格式不同，选项本身也不同，并不只是换个写法而已。

使用 ps 命令的关键不在于记住所有可用的选项，而在于记住对你来说最有用的那些。大多数 Linux 系统管理员会牢记自己的一组常用选项，以用来提取有用的进程信息。

不要一次性学所有风格。建议按以下顺序学习：

* 先学 Unix 风格的 ps -ef（想看所有进程） 和 ps -eLf（看线程）；
* 然后学 BSD 风格的 ps aux | grep 程序名，配合 grep 查进程（想查某个程序是否在运行）；
* 最后了解 GNU 长选项，用来定制你自己的进程查看方式，例如 --sort、--forest、--pid 等增强功能（想更漂亮地看结构或排序）。

ps 命令默认只显示运行在当前终端中属于当前用户的那些进程，输出非常有限：

* PID：进程ID。
* TTY：进程是从哪个终端设备启动的。
* TIME：运行进程的累计CPU时间。
* CMD：启动的程序名称。

更常用的是搭配参数来使用，常见用法如下：

!!! ''ps -ef''

如果需要查看系统中运行的所有进程，可以使用 -ef 选项组合（ps命令允许像这样把选项合并在一起）。

* ps -ef
** -e：等价于 -A，表示显示显示系统中运行的所有进程
** -f：全格式输出（会包含父进程 PID、命令路径等）

全格式指：比默认输出包含更多、对排查和分析更有用的信息字段。它是一种约定俗成的说法，并不是指具体的哪种格式（只要比默认输出包含更多字段，就是全格式），输出如下：

* UID：启动该进程的用户。
* PID：进程ID。
* PPID：父进程的PID（如果该进程是由另一个进程启动的）。
* C：进程生命期中的CPU利用率。
* STIME：进程启动时的系统时间。
* TTY：进程是从哪个终端设备启动的。
* TIME：运行进程的累计CPU时间。
* CMD：启动的程序名称。

!!! ''ps -l''

如果还想获得更多的信息，可以使用 -l 选项，产生长格式输出。

* ps -l：显示当前终端下进程的详细信息（长格式）

注意使用了 -l 选项之后多出的那几列：

* F：内核分配给进程的系统标志。
* S：进程的状态（O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，已终止但找不到其父进程；T代表停止）。
* PRI：进程的优先级（数字越大，优先级越低）。
* NI：谦让度（nice），用于决定优先级。
* ADDR：进程的内存地址。
* SZ：进程被换出时所需交换空间的大致大小。
* WCHAN：进程休眠的内核函数地址。

!!! ''ps -eLf''

查看所有进程及其线程的详细信息，可以使用 ps -eLf：

* ps -eLf 
** -e 表示显示所有进程（所有用户的，不仅是当前用户的）。
** -L 表示显示每个进程的所有线程（Lightweight processes，轻量级进程）。
** -f 表示以完整格式（full-format）显示进程详细信息，包括UID、PID、PPID、C、STIME、TTY、TIME、CMD 等字段。

执行 ps -eLf 后，会列出系统中所有进程及其线程，且每行显示的内容较为全面，适合用来查看多线程程序的线程详情和进程之间的关系。

-L 选项显示所有线程（LWP，轻量级进程），也就是说，每个线程会单独占一行。同时会多显示以下字段：

* LWP：线程ID
* NLWP：进程中线程总数
* PSR：线程所在CPU核编号
* PRI：线程优先级
* NI：线程的nice值

!!! ''ps l''

ps l 是 BSD 风格写法，作用和 ps -l 一致，都是：显示当前终端下进程的详细信息（长格式），但是也有不同之处：

* VSZ：进程占用的虚拟内存大小（以KB为单位）。
* RSS：进程在未被交换出时占用的物理内存大小。
* STAT：代表当前进程状态的多字符状态码。

很多系统管理员喜欢 BSD 风格的 l 选项，因为能输出更详细的进程状态码（STAT列）。多字符状态码能比 Unix 风格输出的单字符状态码更清楚地表明进程的当前状态。

第一个字符采用了与 Unix 风格的 S 输出列相同的值，表明进程是在休眠、运行还是等待。第二个字符进一步说明了进程的状态。

* <：该进程以高优先级运行。
* N：该进程以低优先级运行。
* L：该进程有锁定在内存中的页面。
* s：该进程是控制进程。
* l：该进程拥有多线程。
* +：该进程在前台运行。

从先前展示的简单例子中可以看出，bash命令处于休眠状态，但同时它也是一个控制进程（会话中的主进程），而ps 命令则运行在系统前台。

!!! ''ps aux''

这是最常见的组合之一，含义如下：

* a：显示所有用户的进程
* u：以用户为主的格式输出（显示用户、CPU 占用、内存占用等）
* x：显示没有控制终端的进程（即后台进程）

这个命令输出的是系统上所有进程的详细信息，每一行代表一个进程，字段如：

* USER：进程所属用户
* PID：进程 ID
* %CPU：CPU 使用率
* %MEM：内存使用率
* VSZ：占用的虚拟内存大小（KB）
* RSS：占用的物理内存大小（KB）
* STAT：进程状态（如 S 表示休眠，R 表示运行，Z 表示僵尸等）
* START：进程启动时间
* TIME：CPU 占用总时间
* COMMAND：启动这个进程的命令

如果你只想找某个程序，可以结合 grep 使用，例如：

```
ps aux | grep nginx
```

!!! ''ps --forest''

ps --forest 用来以树状结构展示进程之间的父子关系，非常适合查看谁是哪个进程的子进程（查看一个程序启动了哪些子进程）。

常见组合：

* ps -ef --forest：列出所有进程（-ef），并以树状结构显示。
* ps -e --forest -o pid,ppid,cmd：列出所有进程（-e），显示为树状结构，字段为 PID、PPID 和命令。

应用场景

* 调试某些父子进程关系复杂的服务（比如 systemd、Java 程序、多级 shell 脚本等）
* 分析谁是哪个进程的子进程
* 查找一个进程退出后是否留下孤儿进程

!! ''top''

ps 只能显示某个特定时间点的信息。如果想观察那些被频繁换入和换出内存的进程，ps命令就不太方便了。这正是top 命令的用武之地。

top 是 Linux 系统中用于实时查看进程活动和系统资源使用情况的命令行工具。它会持续刷新系统状态，让你动态监控 CPU、内存、负载等资源使用情况，是性能分析和系统诊断的常用工具。

与 ps 命令相似，top 命令也可以显示进程信息，但采用的是实时方式。

执行 top 后，默认会每隔 3 秒刷新一次当前系统运行状态，包括：

* 系统整体信息（如 uptime、负载、CPU 使用率、内存占用）
* 所有活跃进程的详细信息（如 PID、USER、%CPU、%MEM、COMMAND）

运行 top 后，屏幕内容大致如下：

* 输出的第一部分显示的是系统概况：第一行显示了当前时间、系统的运行时长、登录的用户数以及系统的平均负载。
** 平均负载有3个值，分别是最近1分钟、最近5分钟和最近15分钟的平均负载。值越大说明系统的负载越高。由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见。但如果近15分钟内的平均负载都很高，就说明系统可能有问题了。
** 注意：Linux系统管理的难点在于定义究竟到什么程度才算是高负载。这个值取决于系统的硬件配置以及系统中通常运行的程序。某个系统的高负载可能对其他系统来说就是普通水平。最好的做法是注意在正常情况下系统的负载情况，这样将更容易判断系统何时负载不足。
* 第二行显示了进程（top称其为task）概况：多少进程处于运行、休眠、停止以及僵化状态（僵化状态指进程已结束，但其父进程没有响应）。
* 第三行显示了CPU概况。top会根据进程的属主（用户或是系统）和进程的状态（运行、空闲或等待）将CPU利用率分成几类输出。
* 紧跟其后的两行详细说明了系统内存的状态。前一行显示了系统的物理内存状态：总共有多少内存、当前用了多少，以及还有多少空闲。后一行显示了系统交换空间（如果分配了的话）的状态。
* 最后一部分显示了当前处于运行状态的进程的详细列表，有些列跟ps命令的输出类似。
** PID：进程的PID。
** USER：进程属主的用户名。
** PR：进程的优先级。
** NI：进程的谦让度。
** VIRT：进程占用的虚拟内存总量。
** RES：进程占用的物理内存总量。
** SHR：进程和其他进程共享的内存总量。
** S：进程的状态（D代表可中断的休眠，R代表运行，S代表休眠，T代表被跟踪或停止，Z代表僵化）。
** %CPU：进程使用的CPU时间比例。
** %MEM：进程使用的可用物理内存比例。
** TIME+：自进程启动到目前为止所占用的CPU时间总量。
** COMMAND：进程所对应的命令行名称，也就是启动的程序名。

在默认情况下，top命令在启动时会按照 %CPU 值来对进程进行排序，你可以在 top 命令运行时使用多种交互式命令来重新排序。

在 `top` 命令运行界面中可直接使用键盘输入控制：

| 快捷键 | 功能说明             |
| --- | ---------------- |
| `q` | 退出 `top`         |
| `P` | 按 CPU 占用排序（默认）   |
| `M` | 按内存占用排序          |
| `T` | 按时间累计排序          |
| `k` | 杀死某个进程（输入 PID）   |
| `r` | 重设某进程优先级（renice） |
| `1` | 显示每个 CPU 核心的使用情况 |
| `h` | 查看帮助             |


每个交互式命令都是单字符，在 top 命令运行时键入可改变 top 的行为。键入 f 允许你选择用于对输出进行排序的字段，键入d允许你修改轮询间隔（polling interval），键入 q 可以退出top。用户对 top命令输出有很大的控制权。利用该工具，你经常能找出占用系统大量资源的罪魁祸首。当然，找到之后，下一步就是结束这些进程。这也正是接下来的话题。

!! ''kill''

kill 是 Linux 中用于向进程发送 TERM 信号的命令，最常用于终止进程（即“杀死进程”），但它不仅限于此，也可以用来暂停、重启、挂起等操作，具体取决于发送的信号类型。

* kill <PID>：其中 <PID> 是进程的编号。

几个常用 TERM 信号如下：

* 1)  SIGHUP    重新读取配置（通常用于守护进程）
* 2)  SIGINT    中断（类似 Ctrl+C）
* 9)  SIGKILL   强制终止
* 15) SIGTERM   请求终止（默认）
* 18) SIGCONT   继续（用于让暂停的进程继续）
* 19) SIGSTOP   暂停（不能被捕获或忽略）

例子：

* 终止某个进程：kill 1234
* 强制终止：kill -9 1234
* 用信号名称发送：kill -SIGKILL 1234
* 查看信号名称和对应编号：kill -l
* 批量终止多个进程：kill -9 1234 2345 3456


遗憾的是，你只能使用进程的 PID 而不能使用其对应的程序名，这使得 kill 命令有时并不好用。

要发送进程信号，必须是进程的属主或 root 用户。

默认情况下，kill 发送的是 SIGTERM（信号编号 15），这是一个温和的请求，告诉进程“请你退出”，但进程可以选择忽略，比如正在执行关键操作或被开发者设计成忽略 SIGTERM。如果要强制终止，则 -s 选项支持指定其他信号（用信号名或信号值）。

* kill -s 信号 进程 PID：-s 用于明确指定要发送的信号类型，信号可以使用名称（如 SIGKILL、SIGTERM）或数字（如 9、15）来表示。

例子：

* 使用信号名称强制终止：kill -s SIGKILL 1234
* 或使用信号编号：kill -s 9 1234

注意：SIGKILL（编号 9），这会直接终结进程，不能被捕获、阻塞或忽略。

正常情况下，kill 命令没有输出。如果信号发送成功，它什么也不显示，直接返回 shell 提示符。失败时才提示错误。可通过返回码判断是否成功。要检查 kill 命令是否生效，可以再次执行 ps 命令或 top 命令，看看那些进程是否已经停止运行。

!! ''pkill''

pkill 是 Linux 中用于按进程名称发送信号的命令，作用类似 kill，但更方便，因为它不用查 PID，直接通过进程名操作。

除此之外，pkill命令也允许使用通配符，当系统出问题时，这是一个非常有用的工具：

* pkill http*：该命令将“杀死”所有名称以 http 起始的进程，比如 Apahce Web Server 的 httpd 服务。

pkill 默认发送 SIGTERM 信号（编号 15），也就是请求终止进程。也可以通过 -9 或 -SIGKILL 等方式发送其他信号。

* pkill -9 firefox，或者显式写法：pkill -SIGKILL firefox

警告：以root身份使用pkill命令时要格外小心。命令中的通配符很容易意外地将系统的重要进程终止。这可能会导致文件系统损坏。

kill 和 pkill 给进程发送信号的写法对比：

* kill -s 信号值 PID
* kill -s 信号名 PID
* kill -信号值 PID
* pkill -信号名 进程名
* pkill -信号值 进程名
