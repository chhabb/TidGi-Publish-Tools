created: 20250514175333128
modified: 20250514215104461
tags: 计算机科学/操作系统与虚拟化/Linux/知识体系
title: 计算机科学/操作系统与虚拟化/Linux/知识体系/处理文件

!! ''touch''

touch 命令用来创建空文件，或者更新文件的修改时间和访问时间。

touch 新文件名：touch 命令会创建好指定的文件并将你的用户名作为该文件的属主。新文件的大小为0，因为touch命令只是创建了一个空文件，这个过程不会有任何提示。

touch 已存在的文件名：不会改变文件内容，但是会将文件的“访问时间”和“修改时间”更新为当前时间。

touch touch a.txt b.txt c.txt：同时创建多个空文件，如果文件已经存在，则更新文件的时间

!! ''cp''

cp 命令用于将文件和目录从文件系统的一个位置复制到另一个位置。

cp 源对象 目标对象：将源对象复制到目标对象。当参数源对象、目标对象都是文件名时，cp命令会将源文件复制成一个新的目标文件，并以目标对象命名。新文件在形式上就像全新的文件一样，有新的修改时间（当前时间）。

cp 源对象 目标目录/：将源对象复制到指定目录当中。目标目录名尾部加上一个正斜线（/），这表明目标目录是一个目录而非文件。这有助于表明目的，而且在复制单个文件时非常重要。如果没有使用正斜线，同时目标目录又不存在，就会产生麻烦。在这种情况下，试图将一个文件复制到目标目录反而会创建名为目标目录名的文件，更是连错误消息都不会有。因此，记得在目标目录名尾部加上正斜线。

cp 命令的两个参数，在标准用法中基本涵盖了以下几种情形：

第一个参数（源）可以是：

* 单个文件名（如 a.txt）
* 相对路径下的文件（如 docs/a.txt）
* 绝对路径下的文件（如 /home/user/a.txt）
* 多个文件名（如 cp a.txt b.txt c.txt target_dir/，用于复制多个文件）

第二个参数（目标）可以是：

* 目标文件名（如 b.txt，表示把源复制成一个新文件名）
* 相对路径下的目录（如 backup/，把文件复制进这个目录）
* 绝对路径下的目录（如 /home/user/backup/）
* 存在的目录名（用于将多个文件复制进去）

!!! 选项

!!!! ''-i''

-i 选项用于防止误覆盖文件。当你使用 cp -i 复制文件，如果目标文件已存在，系统会在执行覆盖前提示你确认，你需要输入 y（yes）或 n（no）来决定是否覆盖该文件。如果目标文件不存在，则直接复制，不会进行询问。

!!!! ''-R 或 -r''

-R 或 -r 选项用于在单个命令中递归地复制整个目录的内容，它的两个参数都是目录：cp -R 目录1 目录2：

* 复制 目录1 及其所有内容（包括子目录和文件）
* 如果 目录2 已存在，那么 目录1 会被复制到它里面，形成 目录2/目录1
* 如果 目录2 不存在，那么复制后的目录名就是 目录2

注意：新的 目录2 中所有的文件都有对应的新日期。

如果不加 -R 或 -r 复制目录时就会报错。

!!! ''通配符''

cp 命令中使用通配符，可以实现批量复制匹配的文件，非常适合在处理大量文件时快速选取目标。通配符本身是由 shell（如 bash）进行展开的，cp 接收到的是已展开的文件列表。

常见通配符及用法：

1. 星号 *：匹配零个或多个任意字符

```
cp *.txt backup/
```

复制当前目录下所有 .txt 文件到 backup/ 目录中。

2. 问号 ?：匹配任意单个字符

```
cp file?.txt backup/
```

匹配如 file1.txt、fileA.txt 等，但不匹配 file10.txt（因为 ? 只匹配一个字符）。

3. 方括号 []：匹配特定范围内的单个字符

```
cp file[1-3].txt backup/
```

匹配 file1.txt、file2.txt、file3.txt。

```
cp file[a-c].txt backup/
```

匹配 filea.txt、fileb.txt、filec.txt。

4. 取反 [!abc]：匹配不在指定范围内的单个字符

```
cp file[!1-3].txt backup/
```

匹配除了 file1.txt、file2.txt、file3.txt 以外的如 file4.txt、filex.txt。

!! ''ln''

链接文件是Linux文件系统的一个优势。如果需要在系统中维护同一文件的两个或多个副本，可以使用单个物理副本加多个虚拟副本（链接）的方法代替创建多个物理副本。链接是目录中指向文件真实位置的占位符。

ln 原文件 目标链接：创建一个硬链接。

硬链接创建的是一个独立的虚拟文件，其中包含了原始文件的信息以及位置。但是两者就根本而言是同一个文件。要想创建硬链接，原始文件必须事先存在。

特点：

* 共享 inode：硬链接与原文件拥有相同的 inode 编号，指向同一块磁盘数据区域。
* 大小相同：硬链接与原文件拥有相同的文件大小。
* 平等地位：原文件和硬链接没有主次之分，删除任何一个都不会影响其他的访问，只要还有一个链接存在，文件内容就不会被删除。
* 不能跨文件系统：硬链接只能在同一个分区、存储设备内使用。
* 不能对目录使用：为了防止形成文件系统循环，普通用户无法创建目录的硬链接（只有超级用户在特殊场景下才可能操作）。

!!! ''选项''

!!!! ''-s''

-s 用来创建符号链接（Symbolic Link）：ln -s 原文件 目标链接（创建一个符号链接文件，名字是“目标链接”，它指向“原文件”。）

符号链接（也称为软链接）是一个实实在在的文件，该文件指向存放在虚拟目录结构中某个地方的另一个文件。这两个以符号方式链接在一起的文件彼此的内容并不相同。

符号链接相当于一种快捷方式或指针，指向另一个文件或目录。

要为一个文件创建符号链接，原始文件必须事先存在。

特点：

* 符号链接是一个独立文件，里面保存的是路径信息；
* 删除符号链接不会影响原文件；
* 如果原文件被删除，符号链接就“断链”了，打不开；
* 可以链接文件，也可以链接目录；
* 可以跨分区、存储设备使用；
* 常用于跨目录引用、共享配置文件、简化路径等场景。

可以像对待正常文件一样操作符号链接文件，例如 cat 符号链接文件、vim 符号链接文件，系统会帮你转到原文件上去。

''使用 ls -l 查看符号链接''

当你使用 ls -l 查看符号链接（通过 ln -s 创建的文件）时，输出会清楚地显示这是一个符号链接，并且会标出它所指向的目标路径。

```
lrwxrwxrwx 1 user user     10 5月 15 12:00 myhosts -> /etc/hosts
```

myhosts 是创建出来的符号链接，/etc/hosts是链接指向的原文件。

''文件大小''

符号链接文件与原文件的文件大小并不相同，因为它们的内容并不相同，是两个完全不同的文件。

''查看 inode 节点''

通过 ls -i 查看符号链接文件和原文件的 inode 编号，会发现两者不同，因此链接文件和原文件是两个不同的文件。

!! ''mv''

mv 命令可以将文件和目录移动到另一个位置或是重新命名。

* mv 旧文件名 新文件名：重命名文件
* mv 文件名 目录名：移动文件到指定目录
* mv 旧文件名+旧目录 新文件名+新目录：移动的同时重命名
* mv 旧目录 新目录：移动目录
* mv 旧目录名 新目录名：移动目录同时重命名

同一文件系统内，mv 命令通过更新目录项来“移动”文件，只影响文件名，文件的 inode 编号和时间戳保持不变。
在不同文件系统间，mv 命令执行的是复制和删除操作（复制原文件到新的文件系统，然后删除原文件），导致文件有新的 inode 编号。

!!! ''选项''

!!!! ''-i''

和 cp 命令类似，你也可以在 mv 命令中使用 -i 选项。这样在 mv 试图覆盖已有的文件时（出现了同名文件）会发出询问。

!! ''rm''

rm 命令用来删除文件。

* rm 文件名：删除文件
* rm 文件名1 文件名2 文件名3：删除多个文件

!!! ''选项''

!!!! ''-i''

-i 选项会询问你是否真的要删除该文件。shell 没有回收站或者垃圾箱这样的东西，文件一旦被删除，就再也找不回来了。所以在使用 rm 命令时，要养成总是加入 -i 选项的好习惯。

!!!! ''-r或-R''

rm 默认只删除文件。如果要删除目录，必须使用 -r 或 -R 选项。

* rm -r 目录名
* rm -R 目录名

-r（recursive）或 -R 选项表示递归删除目录及其包含的所有文件和子目录。删除过程是递归进行的，直到目录内的所有内容都被删除。

对于 rm 命令，-r 选项和 -R 选项的效果是一样的，都可以递归地删除目录中的文件。shell 命令很少会对相同的功能使用大小写不同的选项。

!!!! ''-f''

-f 选项可以强制删除文件或目录，即使文件没有写权限或没有确认，rm 也会删除它们。

* rm -f 目录名
* rm -f 文件名

-f（force）选项让 rm 忽略不存在的文件，并且不会显示错误消息。

!!!! ''-rf''

强制递归删除目录及其内容：

* rm -rf 目录名

!!! ''通配符''

使用 * 删除所有匹配的文件：

* rm *.txt：删除当前目录下所有以 .txt 结尾的文件。
* rm file*：删除当前目录下以 file 开头的所有文件，比如 file1、file_test.txt 等。

使用 ? 删除匹配单个字符的位置：

* rm file?.txt：删除所有名为 fileX.txt 的文件，其中 X 是任意单个字符，如 file1.txt、fileA.txt，但不包括 file10.txt（因为 ? 只匹配一个字符）。

使用 [] 指定字符集范围：

* rm file[123].txt：删除 file1.txt、file2.txt、file3.txt。
* rm file[a-c].txt：删除 filea.txt、fileb.txt、filec.txt。

使用 [!...] 进行排除匹配：

* rm file[!1].txt：删除除了 file1.txt 之外的所有 fileX.txt 文件，比如 file2.txt、file3.txt 等。

多种通配符组合使用：

* rm data[1-3]?.csv：删除所有匹配 data1X.csv 到 data3X.csv 的文件，其中 X 是任意单个字符，比如 data11.csv、data23.csv 等。

使用 * 删除所有文件：

* rm *：删除当前目录下的所有文件，不包括隐藏文件（以 . 开头的文件）。

删除隐藏文件：

* rm .*：危险操作，可能会删除当前目录下的 .（当前目录）和 ..（上级目录）符号链接（尽管 rm 默认不会删除这两个，但风险很大）。
* rm .[^.]* （推荐使用）：它会匹配以 . 开头但不是 .. 的隐藏文件。